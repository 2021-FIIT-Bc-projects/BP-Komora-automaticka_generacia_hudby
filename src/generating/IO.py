import json

from music21 import note
from music21 import instrument
from music21 import chord
from music21 import stream


def loadParams():

    with open('config.json') as configFile:
        param_dict = json.load(configFile)

    mandatory_params = ["no_of_timesteps", "LSTM_size", "Dense_size", "recurrent_dropout", "batch_size", "no_of_epochs"]
    for param in mandatory_params:
        if param not in param_dict:
            raise ValueError("%s have to be included in config.json" % param)

    return param_dict


def load_data(path):
    pass


def load_random():
    pass


def load_training()
    


def export_music(prediction_output, filename='music.mid'):
    offset = 0
    output_notes = []

    # create note and chord objects based on the values generated by the model
    for pattern in prediction_output:

        if ' ' in pattern:
            element, quarterLength = pattern.split(' ')
        else:
            element = pattern
            quarterLength = '1.0'

        if '/' in quarterLength:
            x, y = quarterLength.split('/')
            quarterLength = float(x)/float(y)
        else:
            quarterLength = float(quarterLength)

        # element is a rest
        if element == 'Rest':
            new_note = note.Rest(quarterLength=quarterLength)
            output_notes.append(new_note)

        # element is a chord
        elif ('.' in element) or element.isdigit():
            notes_in_chord = element.split('.')
            notes = []
            for current_note in notes_in_chord:
                new_note = note.Note(int(current_note), quarterLength=quarterLength)
                new_note.storedInstrument = instrument.Piano()
                notes.append(new_note)

            new_chord = chord.Chord(notes)
            new_chord.offset = offset
            output_notes.append(new_chord)

        # element is a note
        else:
            new_note = note.Note(element, quarterLength=quarterLength)
            new_note.offset = offset
            new_note.storedInstrument = instrument.Piano()
            output_notes.append(new_note)

        # increase offset each iteration so that notes do not stack
        offset += 1

    midi_stream = stream.Stream(output_notes)
    folder = 'output\\'
    path = folder + filename
    midi_stream.write('midi', fp=path)


def bundle_output():
    pass
