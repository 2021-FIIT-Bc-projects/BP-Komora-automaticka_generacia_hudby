import os
import json
import shutil
import random
import datetime

import numpy as np
import pandas as pd
from music21 import note
from music21 import instrument
from music21 import chord
from music21 import stream

from keras.models import load_model


def load_data(path):
    # Target directory
    extract_dir = "./input"

    # Format of archive file
    archive_format = "zip"

    # Unpack the archive file
    try:
        shutil.unpack_archive(path, extract_dir, archive_format)
        print("Archive file unpacked successfully.")
    except shutil.ReadError:
        raise ValueError("%s is not recognized as a zip file" % path)

    with open('input/notes.json') as configFile:
        int_to_note = json.load(configFile)

    with open('input/config.json') as configFile:
        params = json.load(configFile)

    model = load_model('input/model.h5')

    return model, int_to_note, params


def load_base_music(approach, n_vocab, no_of_timesteps):

    if approach == "random":
        base_music = []
        for i in range(no_of_timesteps):
            base_music.append(random.randint(0, n_vocab - 1)/n_vocab)

        base_music = np.array(base_music)

    if approach == "known":
        x_tr = pd.read_csv('input/x_tr.csv', index_col=0)
        base_music = x_tr.sample().to_numpy()[0]

    if approach == "unknown":
        x_val = pd.read_csv('input/x_val.csv', index_col=0)
        base_music = x_val.sample().to_numpy()[0]

    return base_music


def load_training_data():
    x_tr = pd.read_csv('input/x_tr.csv', index_col=0).to_numpy().flatten()
    return x_tr


def export(predicted_notes, filename):
    offset = 0
    output_notes = []

    # create note and chord objects based on the values generated by the model
    for pattern in predicted_notes:

        if ' ' in pattern:
            element, quarterLength = pattern.split(' ')
        else:
            element = pattern
            quarterLength = '1.0'

        if '/' in quarterLength:
            x, y = quarterLength.split('/')
            quarterLength = float(x)/float(y)
        else:
            quarterLength = float(quarterLength)

        # element is a rest
        if element == 'Rest':
            new_note = note.Rest(quarterLength=quarterLength)
            output_notes.append(new_note)

        # element is a chord
        elif ('.' in element) or element.isdigit():
            notes_in_chord = element.split('.')
            notes = []
            for current_note in notes_in_chord:
                new_note = note.Note(int(current_note), quarterLength=quarterLength)
                new_note.storedInstrument = instrument.Piano()
                notes.append(new_note)

            new_chord = chord.Chord(notes)
            new_chord.offset = offset
            output_notes.append(new_chord)

        # element is a note
        else:
            new_note = note.Note(element, quarterLength=quarterLength)
            new_note.offset = offset
            new_note.storedInstrument = instrument.Piano()
            output_notes.append(new_note)

        # increase offset each iteration so that notes do not stack
        offset += 1

    midi_stream = stream.Stream(output_notes)
    folder = 'output\\'
    path = folder + filename
    midi_stream.write('midi', fp=path)
    # midi_stream.write(fp=path)


def init_output():
    parent_dir = os.path.abspath(".")
    dirname = "output"
    path = os.path.join(parent_dir, dirname)

    if not os.path.exists(path):
        os.makedirs(path)


def bundle_output(no_of_timesteps, model='', base_music=''):
    parent_dir = os.path.abspath(".")
    dirname = "output"
    path = os.path.join(parent_dir, dirname)

    dt = datetime.datetime.now()
    day = dt.strftime("%d")
    month = dt.strftime("%m")

    filename = "../../output/generated/%s-%s %s_(%d)_%s" % (day, month, model, no_of_timesteps, base_music)
    file_format = "zip"
    root_dir = "./output"
    shutil.make_archive(filename, file_format, root_dir)
    shutil.rmtree(path)

    print('All files zipped successfully!')
    print(filename)

    parent_dir = os.path.abspath(".")
    path = os.path.join(parent_dir, "input")
    shutil.rmtree(path)
