import argparse
import numpy as np


from IO import load_data, init_output, load_base_music
from IO import bundle_output
from IO import export
from IO import load_training_data


def generate_music(random_music, model, no_of_timesteps, n_vocab, range_of_prediction=10):
    predictions = []

    for i in range(range_of_prediction):
        random_music = random_music.reshape(1, no_of_timesteps)

        random_music = np.reshape(random_music, (random_music.shape[0], 1, random_music.shape[1]))
        prob = model.predict(random_music)[0]

        y_pred = np.argmax(prob, axis=0)
        predictions.append(y_pred)

        random_music = np.insert(random_music[0][0], len(random_music[0][0]), y_pred / n_vocab)
        random_music = random_music[1:]

    return np.array(predictions)


def findSequences(generated_music, n_vocab):

    max_sub_array = 0
    training_data = load_training_data()

    for index in range(4):

        sub_array = 0

        for item in training_data:

            if generated_music[index + sub_array] == round(item * n_vocab):
                sub_array += 1

            else:
                sub_array = 0

            if sub_array > max_sub_array:
                max_sub_array = sub_array

    print("Longest sub-sequence: " + str(max_sub_array))


if __name__ == "__main__":

    # create a parser object
    parser = argparse.ArgumentParser(description="An addition program")

    # add argument
    parser.add_argument("-path", type=str, nargs=1, metavar="path trained model")
    parser.add_argument("-base", type=str, nargs=1, default="unknown", metavar="type of base music for prediction")
    parser.add_argument("-pred", type=int, nargs=1, default=[5], metavar="number of predictions")
    parser.add_argument("-len", type=int, nargs=1, default=[32], metavar="length of prediction")

    # parse the arguments from standard input
    args = parser.parse_args()

    # Load data
    input_path = args.path[0]
    model, int_to_note, params = load_data(input_path)

    print(params)
    n_vocab = len(int_to_note)

    base_music_type = args.base[0]
    predictions = args.pred[0]
    prediction_length = args.len[0]

    init_output()

    print(input_path)
    # Generate predictions
    for i in range(predictions):
        base_music = load_base_music(base_music_type, len(int_to_note), params['no_of_timesteps'])
        prediction = generate_music(base_music, model, params['no_of_timesteps'], n_vocab, range_of_prediction=prediction_length)
        predicted_notes = [int_to_note[str(i)] for i in prediction]
        export(predicted_notes, filename=('%s_autogenerated_music_%d.mid' % (params["model"], i + 1)))

        findSequences(prediction, len(int_to_note))

    if params["model"]:
        bundle_output(params['no_of_timesteps'], params["model"], base_music_type)
    else:
        bundle_output(params['no_of_timesteps'])
